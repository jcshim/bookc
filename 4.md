### 1장: 함수의 정의와 호출, 매개변수 전달 방식

#### 1.1 함수의 정의  
함수는 특정 작업을 수행하는 독립된 코드 블록으로, 프로그램을 모듈화하여 코드의 재사용성과 가독성을 높인다.  
함수를 정의할 때는 반환 자료형, 함수 이름, 매개변수 목록을 지정하며, 함수 본문에 실제 작업을 구현한다.  
기본 문법은 다음과 같다:
```c
반환형 함수명(매개변수 목록) {
    // 함수가 수행할 작업을 구현한다.
}
```
예를 들어, 두 수의 합을 계산하는 함수를 다음과 같이 정의한다:
```c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}
```
이 예제에서 함수 `add`는 정수형 매개변수 `a`와 `b`를 받아, 두 수의 합을 반환한다.

#### 1.2 함수의 호출  
함수를 호출하면, 정의된 함수의 코드가 실행되며 필요에 따라 결과값을 반환받는다.  
함수 호출 시에는 함수 이름과 괄호 안에 인수를 전달한다.  
예를 들어, 위에서 정의한 `add` 함수를 호출하는 코드는 다음과 같다:
```c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int main(void) {
    int result = add(3, 4);
    printf("합: %d\n", result);
    return 0;
}
```
이 코드에서 `add(3, 4)`를 호출하여 두 수의 합을 구하고, 그 결과를 변수 `result`에 저장한 후 출력한다.

#### 1.3 매개변수 전달 방식  
C언어에서 함수로 값을 전달하는 기본 방식은 **값에 의한 전달(Call by Value)**이다.  
- **값에 의한 전달:**  
  함수 호출 시 인수의 값이 복사되어 함수 내부의 매개변수에 전달된다.  
  이 방식에서는 함수 내부에서 매개변수의 값을 변경하더라도 호출한 쪽의 변수에는 영향을 주지 않는다.

또한, 포인터를 활용하여 변수의 주소를 전달하면 **참조에 의한 전달(Call by Reference)** 효과를 얻는다.  
- **참조에 의한 전달:**  
  변수의 주소를 전달함으로써, 함수 내부에서 직접 원본 데이터를 수정할 수 있다.  
  이 경우, 함수에서 변경한 값이 호출한 쪽의 변수에도 반영된다.

예제 코드를 통해 두 전달 방식을 비교하면 다음과 같다:
```c
#include <stdio.h>

// 값에 의한 전달: 인수의 값이 복사되어 전달된다.
void incrementByValue(int n) {
    n = n + 1;
}

// 참조에 의한 전달: 변수의 주소를 전달받아 원본 값을 수정한다.
void incrementByReference(int *n) {
    (*n) = (*n) + 1;
}

int main(void) {
    int a = 5;
    int b = 5;
    
    incrementByValue(a);       // a의 값은 그대로 유지된다.
    incrementByReference(&b);  // b의 값은 1 증가한다.
    
    printf("a = %d\n", a);  // 출력 결과: a = 5
    printf("b = %d\n", b);  // 출력 결과: b = 6
    return 0;
}
```
이 예제에서 `incrementByValue` 함수는 인수 `a`의 값을 복사하여 전달받기 때문에, 함수 내부에서 `n`의 값이 변경되어도 원본 `a`에는 영향을 주지 않는다. 반면, `incrementByReference` 함수는 변수 `b`의 주소를 전달받아 포인터를 통해 원본 데이터를 직접 수정하므로, `b`의 값이 증가된다.

#### 1.4 요약  
- **함수의 정의:** 특정 작업을 수행하는 독립된 코드 블록을 정의하여, 프로그램의 모듈화와 재사용성을 높인다.  
- **함수의 호출:** 함수 이름과 인수를 사용하여 함수를 실행하고, 필요 시 결과값을 반환받는다.  
- **매개변수 전달 방식:**  
  - 값에 의한 전달은 인수의 값을 복사하여 전달하며, 함수 내부에서 변경해도 원본에 영향을 주지 않는다.  
  - 참조에 의한 전달은 변수의 주소를 전달하여, 함수 내부에서 원본 데이터를 직접 수정할 수 있다.

이 장을 통해 학생들은 함수의 기본 개념을 확립하고, 함수 호출 및 매개변수 전달 방식을 이해하여 보다 구조적이고 효율적인 프로그램을 작성하는 기초를 마련한다.

### 2. 재귀 함수 소개

#### 2.1 재귀 함수의 개념  
재귀 함수는 함수가 자기 자신을 호출하여 문제를 해결하는 기법이다.  
문제를 동일한 형태의 더 작은 문제로 나누어 해결하며, 이를 반복하여 최종 결과를 도출한다.  
재귀 함수는 일반적으로 **기본(종료) 조건**과 **재귀(반복) 조건**으로 구성된다.

#### 2.2 기본 조건과 재귀 조건  
- **기본 조건:**  
  재귀 호출을 멈추기 위한 조건이다. 기본 조건이 충족되면 함수는 더 이상 자기 자신을 호출하지 않고 결과를 반환한다.  
- **재귀 조건:**  
  기본 조건에 도달하기 전까지 함수가 자기 자신을 호출하는 조건이다. 문제를 점진적으로 단순화시키면서 기본 조건에 도달하도록 설계한다.

#### 2.3 재귀 함수의 예제 – 팩토리얼 계산  
팩토리얼은 재귀 함수의 대표적인 예로, n!는 n × (n-1)!로 정의된다.  
기본 조건은 1! = 1 또는 0! = 1로 설정한다.

```c
#include <stdio.h>

int factorial(int n) {
    if (n <= 1)       // 기본 조건: n이 1 이하이면 1을 반환
        return 1;
    else              // 재귀 조건: n이 2 이상인 경우 자기 자신을 호출
        return n * factorial(n - 1);
}

int main(void) {
    int number = 5;
    printf("팩토리얼: %d\n", factorial(number));  // 5! = 120 출력
    return 0;
}
```

이 예제에서 `factorial` 함수는 n이 1 이하가 될 때까지 자기 자신을 호출하여 문제를 점차 축소한 후, 기본 조건에 따라 결과를 반환한다.

#### 2.4 재귀 함수의 장점과 주의 사항  
- **장점:**  
  - 문제를 간결하고 직관적으로 표현할 수 있다.  
  - 복잡한 문제를 단순한 형태로 분할하여 해결할 수 있다.
  
- **주의 사항:**  
  - 기본 조건이 없거나 부적절하면 무한 재귀 호출로 이어져 스택 오버플로우가 발생할 수 있다.  
  - 반복문으로 해결 가능한 문제에 대해 재귀를 사용할 경우, 성능 면에서 비효율적일 수 있다.

#### 2.5 요약  
재귀 함수는 문제를 자기 자신을 호출하는 방식으로 해결하며, 기본 조건과 재귀 조건의 명확한 설정이 필수적이다.  
학생들은 재귀 함수를 활용하여 복잡한 문제를 더 작은 문제로 분할해 해결하는 방법을 익히며, 동시에 재귀 호출의 잠재적 위험에 대해 주의하는 습관을 기른다.

### 3. 코드 모듈화 및 함수 분리 실습

#### 3.1 코드 모듈화의 개념  
코드 모듈화는 프로그램을 기능별로 독립된 단위(함수 또는 모듈)로 나누어 작성하는 것을 말한다.  
이렇게 분리된 코드는 가독성이 높아지고, 유지보수와 재사용이 용이해진다.  
하나의 큰 문제를 여러 개의 작은 문제로 나누어 해결하는 방식은 복잡한 프로그램을 체계적으로 관리하는 데 큰 도움이 된다.

#### 3.2 함수 분리 실습 예제  
이번 실습에서는 두 정수를 입력받아 기본적인 산술 연산(덧셈, 뺄셈, 곱셈, 나눗셈)을 수행하는 프로그램을 작성한다.  
하나의 함수에 모든 기능을 넣는 대신, 각 연산을 별도의 함수로 분리하여 코드 모듈화를 실천한다.

#### 3.3 예제 코드 및 설명  
다음은 함수 분리를 통해 작성된 예제 코드이다:

```c
#include <stdio.h>

// 두 정수의 덧셈을 수행하는 함수
int add(int a, int b) {
    return a + b;
}

// 두 정수의 뺄셈을 수행하는 함수
int subtract(int a, int b) {
    return a - b;
}

// 두 정수의 곱셈을 수행하는 함수
int multiply(int a, int b) {
    return a * b;
}

// 두 정수의 나눗셈을 수행하는 함수 (분모가 0인 경우 에러 처리)
float divide(int a, int b) {
    if (b != 0)
        return (float)a / b;
    else {
        printf("Error: Division by zero.\n");
        return 0;
    }
}

int main(void) {
    int num1, num2;

    // 사용자로부터 두 정수를 입력받는다.
    printf("두 정수를 입력하시오: ");
    scanf("%d %d", &num1, &num2);

    // 각 기능별로 분리된 함수를 호출하여 결과를 출력한다.
    printf("덧셈 결과: %d\n", add(num1, num2));
    printf("뺄셈 결과: %d\n", subtract(num1, num2));
    printf("곱셈 결과: %d\n", multiply(num1, num2));
    printf("나눗셈 결과: %.2f\n", divide(num1, num2));

    return 0;
}
```

**코드 설명:**  
- 각 산술 연산(덧셈, 뺄셈, 곱셈, 나눗셈)을 수행하는 함수를 별도로 정의하여, 기능별로 코드를 분리하였다.  
- `main` 함수에서는 사용자로부터 두 정수를 입력받은 후, 각 함수를 호출하여 결과를 출력한다.  
- `divide` 함수에서는 분모가 0일 경우 에러 메시지를 출력하고 0을 반환하는 방식으로 예외 상황을 처리하였다.

#### 3.4 코드 모듈화의 장점  
- **가독성 향상:**  
  각 기능이 독립적인 함수로 구분되어 있어, 코드의 흐름을 쉽게 파악할 수 있다.
- **유지보수 용이:**  
  한 기능에 문제가 발생하면 해당 함수만 수정하면 되므로, 전체 코드를 수정할 필요가 줄어든다.
- **재사용성 증대:**  
  분리된 함수는 다른 프로그램이나 모듈에서도 재사용할 수 있어, 개발 효율을 높인다.

#### 3.5 요약  
코드 모듈화와 함수 분리는 프로그램을 체계적으로 구성하여 가독성, 유지보수, 재사용성을 크게 향상시킨다.  
이번 실습을 통해 학생들은 큰 문제를 작은 기능 단위로 분리하는 방법을 직접 체험하며, 모듈화된 코드를 작성하는 실전 경험을 쌓는다.

