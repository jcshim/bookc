# 1. 그래픽스 프로그래밍 개요

그래픽스 프로그래밍은 단순한 텍스트 기반의 출력에서 벗어나, 컴퓨터 화면에 시각적인 요소를 생성하고 제어하는 기술이다. 이 분야는 픽셀 단위의 정밀한 제어를 통해 이미지, 도형, 텍스트, 애니메이션 등을 구현하며, 사용자와의 인터랙션을 가능하게 한다. C언어와 같은 저수준 언어를 사용하면 하드웨어 자원과 밀접하게 작업할 수 있어, 성능 최적화와 직접적인 메모리 제어가 중요한 역할을 한다.

---

## 1.1 그래픽스 프로그래밍의 기본 개념

- **픽셀 제어:**  
  화면은 수많은 픽셀로 구성되며, 각 픽셀은 특정 위치와 색상 정보를 가진다. 그래픽스 프로그래밍은 이 픽셀들의 색상, 밝기, 위치 등을 직접 설정하거나 변경함으로써 원하는 이미지를 생성한다.

- **좌표 시스템:**  
  모든 그래픽 요소는 좌표 시스템을 기반으로 위치가 지정된다. 2D 그래픽에서는 보통 왼쪽 상단을 (0, 0)으로 하여 x축은 오른쪽, y축은 아래로 증가하는 방식으로 좌표를 표현하며, 3D 그래픽에서는 z축을 추가하여 깊이를 표현한다.

- **색상 모델:**  
  대부분의 그래픽 시스템은 RGB(빨강, 초록, 파랑) 색상 모델을 사용한다. 때때로 투명도를 표현하기 위해 알파 채널을 추가한 RGBA 모델도 활용된다. 이러한 색상 모델은 픽셀 단위의 색상 정보를 설정하는 기본 단위이다.

- **렌더링 파이프라인:**  
  그래픽스 프로그래밍에서는 도형이나 이미지를 화면에 출력하기 위해 여러 단계를 거치는 렌더링 파이프라인을 사용한다. 여기에는 객체의 모델링, 변환, 투영, 클리핑, 그리고 최종적으로 픽셀 단위의 출력이 포함된다.

---

## 1.2 그래픽스 프로그래밍의 응용 및 중요성

- **실시간 인터랙션:**  
  그래픽스 프로그래밍은 게임, 시뮬레이션, 데이터 시각화 등 실시간 사용자 인터랙션이 중요한 분야에서 핵심 역할을 한다. 사용자의 입력(키보드, 마우스, 터치 등)에 따라 화면의 내용을 동적으로 변경하고, 애니메이션 효과를 주어 몰입감 있는 경험을 제공한다.

- **멀티미디어 콘텐츠 제작:**  
  그래픽스를 이용해 동영상, 이미지 편집, 3D 모델링 등 다양한 멀티미디어 콘텐츠를 제작할 수 있다. 특히, C언어와 같은 저수준 언어를 사용하면 하드웨어 가속 및 최적화된 성능을 구현할 수 있어 복잡한 그래픽 작업을 원활하게 수행할 수 있다.

- **교육 및 연구:**  
  그래픽스 프로그래밍은 컴퓨터 과학의 여러 분야(컴퓨터 비전, 인공지능, 가상 현실 등)와 밀접한 연관이 있으며, 기초적인 그래픽스 개념은 고급 기술을 배우기 위한 토대가 된다. 학생들은 이를 통해 수학적 모델, 알고리즘, 물리 기반 시뮬레이션 등을 이해하고 응용할 수 있다.

- **효율적인 자원 관리:**  
  C언어를 활용한 그래픽스 프로그래밍은 메모리와 CPU 자원의 효율적인 관리가 필수적이다. 저수준의 메모리 제어와 직접적인 하드웨어 접근을 통해, 고성능의 실시간 애플리케이션을 개발할 수 있다.

---

## 1.3 그래픽스 프로그래밍의 개발 프로세스

- **초기화 단계:**  
  그래픽 라이브러리를 초기화하고, 창(Window)과 렌더러(Renderer)를 생성하는 과정이 필수적이다. 이 단계에서는 창의 크기, 제목, 위치 등 기본 속성을 설정하며, 이후의 그리기 작업에 필요한 리소스를 할당한다.

- **그리기 및 렌더링 단계:**  
  초기화된 창 위에 도형, 이미지, 텍스트 등의 그래픽 요소를 그리는 단계이다. 이 과정에서는 더블 버퍼링, 색상 설정, 도형의 위치와 크기 지정 등의 작업이 포함된다. 렌더링 파이프라인을 거쳐 최종적으로 화면에 출력된다.

- **이벤트 처리 단계:**  
  사용자의 입력(마우스 클릭, 키보드 입력 등)을 지속적으로 감지하여 그에 따른 응답을 처리한다. 이벤트 루프를 통해 각종 이벤트를 실시간으로 처리하고, 화면 업데이트 및 애니메이션을 제어한다.

- **업데이트 및 종료 단계:**  
  프로그램은 일정 시간 간격으로 화면을 갱신하고, 필요 시 애니메이션이나 그래픽 요소의 상태를 업데이트한다. 사용자가 종료 명령을 내리면, 할당된 자원을 해제하고, 창을 닫아 프로그램을 종료한다.

---

## 요약

그래픽스 프로그래밍은 C언어를 통해 픽셀 단위의 제어, 좌표 시스템을 기반으로 한 위치 지정, 그리고 RGB 색상 모델을 활용한 시각적 표현을 가능하게 한다. 또한, 실시간 사용자 인터랙션과 효율적인 자원 관리, 그리고 복잡한 렌더링 과정을 포함하는 개발 프로세스를 통해 다양한 멀티미디어 콘텐츠와 인터랙티브 애플리케이션을 구현할 수 있다. 이러한 전반적인 개념과 응용 기술은 현대 컴퓨터 과학 및 엔터테인먼트 분야에서 중요한 역할을 담당하며, 그래픽스 프로그래밍의 기초를 이해하는 것은 앞으로의 고급 개발 기술을 익히는 데 큰 토대가 된다.

## 2. 추천 라이브러리(예: SDL) 설치 및 설정 (Windows, Visual Studio, NuGet 사용)

C언어를 활용한 그래픽스 프로그래밍에서, 복잡한 저수준 하드웨어 제어나 플랫폼 차이를 직접 처리하지 않고도 강력한 그래픽 기능을 구현할 수 있도록 돕는 여러 라이브러리가 있다. 그 중 대표적인 오픈소스 라이브러리인 SDL(Simple DirectMedia Layer)은 창 생성, 이벤트 처리, 2D 렌더링, 오디오 처리 등 멀티미디어 애플리케이션 전반의 기능을 제공하며, 초보자부터 전문가까지 폭넓게 사용된다. 아래는 SDL의 개요와 주요 기능, 그리고 Windows의 Visual Studio 환경에서 NuGet을 이용해 SDL을 설치 및 설정하는 과정을 정리한 내용이다.

---

### 2.1 SDL 라이브러리 개요

- **정의:**  
  SDL은 “Simple DirectMedia Layer”의 약자로, C언어로 개발된 라이브러리이다. 복잡한 하드웨어 제어나 저수준 API를 직접 다루지 않고도, 플랫폼에 독립적인 코드로 창 생성, 이미지 렌더링, 애니메이션, 게임 루프 등을 구현할 수 있도록 추상화된 기능을 제공한다.

- **주요 역할:**  
  - **창 생성 및 관리:** 간단한 함수 호출로 새 창을 만들고, 창의 크기, 제목, 위치 등을 설정할 수 있다.  
  - **렌더링:** 2D 도형, 텍스트, 이미지 등을 하드웨어 가속 기능을 통해 빠르고 부드럽게 출력할 수 있다.  
  - **이벤트 처리:** 키보드, 마우스, 게임패드 등 다양한 입력 장치의 이벤트를 받아 사용자 인터랙션을 구현할 수 있다.

---

### 2.2 SDL의 주요 기능 및 장점

- **크로스 플랫폼 지원:**  
  Windows, macOS, Linux 등 다양한 운영체제에서 동일한 코드로 동작하므로, 플랫폼별 별도 개발이 필요 없다.

- **성능 및 효율성:**  
  저수준 C언어 기반 라이브러리로 직접 메모리 및 하드웨어 자원을 관리할 수 있어, 실시간 애플리케이션이나 게임 개발에 최적화되어 있다.

- **풍부한 멀티미디어 기능:**  
  창 관리, 2D 그래픽 렌더링, 텍스트 출력, 오디오 재생, 입력 처리 등 다양한 기능을 하나의 라이브러리에서 통합적으로 제공한다.

- **활발한 커뮤니티와 문서:**  
  공식 웹사이트, 포럼, GitHub, Stack Overflow 등에서 다양한 자료와 예제, 지원을 받아 문제 해결 및 학습에 큰 도움을 준다.

---

### 2.3 SDL 설치 및 설정 과정 (Windows, Visual Studio, NuGet 사용)

1. **프로젝트 생성:**  
   - Visual Studio를 실행한 후, 새 C 또는 C++ 콘솔 프로젝트를 생성한다.

2. **NuGet 패키지 관리자로 SDL 설치:**  
   - 솔루션 탐색기에서 프로젝트 이름을 오른쪽 클릭하고 **"Manage NuGet Packages..."** 메뉴를 선택한다.  
   - **Browse** 탭에서 **"SDL2"**를 검색한다.  
   - 최신 버전의 SDL2 패키지를 선택한 후 **"Install"** 버튼을 클릭하여 설치한다.  
   - NuGet은 자동으로 SDL의 헤더 파일과 라이브러리 파일을 프로젝트에 추가한다.

3. **프로젝트 설정 확인:**  
   - NuGet을 통해 자동으로 추가된 include 디렉터리와 라이브러리 경로가 올바르게 설정되었는지 확인한다.  
     - 만약 빌드 시 헤더 파일 관련 오류가 발생하면, **프로젝트 속성 > C/C++ > 일반 > 추가 포함 디렉터리**에서 SDL2의 `include` 경로를 점검한다.  
     - 링커 설정은 **프로젝트 속성 > 링커 > 일반 > 추가 라이브러리 디렉터리**에서 확인할 수 있다.

4. **DLL 파일 처리:**  
   - SDL2는 실행 시 동적 라이브러리(`SDL2.dll`)를 필요로 한다.  
   - 만약 이 DLL 파일이 자동으로 출력 폴더에 복사되지 않는다면, 솔루션 탐색기에서 `SDL2.dll` 파일을 찾아 **속성** 창의 **"Copy to Output Directory"** 옵션을 **"Copy if newer"**로 설정하거나, 수동으로 실행 파일 폴더에 복사한다.

5. **테스트 및 검증:**  
   - 아래의 간단한 SDL 예제 코드를 작성하여, SDL 초기화와 창 생성이 정상적으로 이루어지는지 확인한다.

   ```c
   #include <SDL.h>
   #include <stdio.h>

   int main(int argc, char* argv[]) {
       // SDL 초기화
       if (SDL_Init(SDL_INIT_VIDEO) != 0) {
           printf("SDL 초기화 실패: %s\n", SDL_GetError());
           return 1;
       }

       // 640x480 크기의 창 생성
       SDL_Window* window = SDL_CreateWindow("SDL 예제",
                                             SDL_WINDOWPOS_CENTERED,
                                             SDL_WINDOWPOS_CENTERED,
                                             640, 480,
                                             SDL_WINDOW_SHOWN);
       if (window == NULL) {
           printf("창 생성 실패: %s\n", SDL_GetError());
           SDL_Quit();
           return 1;
       }

       // 창을 3초 동안 표시
       SDL_Delay(3000);

       // 창 파괴 및 SDL 종료
       SDL_DestroyWindow(window);
       SDL_Quit();
       return 0;
   }
   ```

   - 이 코드를 빌드하고 실행하면, 3초 동안 창이 정상적으로 나타난 후 종료되어야 한다.

---

### 2.4 SDL 활용 시 고려사항 및 팁

- **공식 문서와 예제 코드 활용:**  
  SDL 공식 문서와 온라인 튜토리얼, 다양한 예제 코드를 참고하여 기본 사용법을 익힌다.

- **디버깅:**  
  헤더 파일, 라이브러리 경로 설정 오류나 DLL 파일 누락 등 초기 설정 오류가 발생할 수 있으므로, 빌드 로그와 오류 메시지를 꼼꼼히 확인한다.

- **커뮤니티 지원:**  
  SDL 관련 포럼, GitHub, Stack Overflow 등을 활용해 문제를 해결하고 최신 업데이트 및 패치를 확인한다.

- **대안 라이브러리 검토:**  
  프로젝트 목적과 개발자의 숙련도에 따라 Allegro, raylib 등 다른 그래픽 라이브러리와 비교하여 선택할 수 있다.

---

### 2.5 요약

- **SDL 개요:**  
  SDL은 창 생성, 렌더링, 이벤트 처리, 오디오 등 멀티미디어 기능을 제공하는 크로스 플랫폼 C언어 기반 라이브러리이다.

- **주요 기능:**  
  창 관리, 2D 렌더링, 사용자 입력 처리, 그리고 높은 성능과 효율성을 제공한다.

- **설치 과정 요약:**  
  Visual Studio에서 새 C/C++ 프로젝트를 생성한 후, NuGet 패키지 관리자를 통해 SDL2를 설치한다. 자동으로 추가된 설정을 확인하고, 필요한 경우 DLL 파일의 "Copy to Output Directory" 옵션을 설정한다.

- **검증:**  
  간단한 SDL 예제 코드를 빌드하고 실행하여, 초기화와 창 생성이 올바르게 이루어졌는지 확인한다.

이 과정을 통해 학생들은 Windows의 Visual Studio 환경에서 NuGet을 사용하여 SDL을 손쉽게 설치하고 설정할 수 있으며, 이를 바탕으로 C언어를 활용한 그래픽스 프로그래밍 실습에 바로 적용할 수 있다.

### 3. 창 생성, 그리기 기본, 이벤트 처리 실습

이 섹션에서는 SDL을 활용하여 간단한 그래픽 애플리케이션을 구현하는 방법을 실습한다.  
구체적으로는 다음 내용을 다룬다:

- **창 생성:**  
  SDL 함수를 사용하여 지정한 크기와 위치의 창을 생성한다.

- **기본 그리기:**  
  창에 렌더러를 통해 배경색을 채우고, 기본 도형(예: 사각형)을 그리는 방법을 익힌다.

- **이벤트 처리:**  
  이벤트 루프를 통해 사용자 입력(예: 창 닫기 버튼 클릭)을 감지하고, 그에 따라 애플리케이션의 동작을 제어한다.

---

#### 3.1 창 생성

- **SDL 초기화:**  
  `SDL_Init(SDL_INIT_VIDEO)` 함수를 호출하여 비디오 관련 기능을 초기화한다.
  
- **창 생성:**  
  `SDL_CreateWindow` 함수를 사용하여, 창의 제목, 크기, 위치 및 표시 옵션을 지정해 창을 생성한다.

- **렌더러 생성:**  
  생성된 창과 연결된 렌더러(`SDL_CreateRenderer`)를 생성하여, 그리기 작업에 활용한다.

---

#### 3.2 기본 그리기

- **배경 색상 설정:**  
  `SDL_SetRenderDrawColor`와 `SDL_RenderClear` 함수를 사용하여, 렌더러의 배경을 특정 색(예: 검정색)으로 채운다.
  
- **도형 그리기:**  
  예제에서는 `SDL_Rect` 구조체를 정의해 사각형의 위치와 크기를 지정한 후, `SDL_RenderFillRect` 함수를 사용하여 채워진 사각형을 그린다.
  
- **렌더링 결과 출력:**  
  `SDL_RenderPresent` 함수를 호출하여, 렌더러의 그리기 결과를 창에 출력한다.

---

#### 3.3 이벤트 처리

- **이벤트 루프 구성:**  
  `SDL_PollEvent` 함수를 이용해 발생하는 이벤트(예: 창 닫기, 키보드 입력 등)를 지속적으로 확인한다.
  
- **종료 조건 처리:**  
  이벤트 루프 내에서 `SDL_QUIT` 이벤트(창의 닫기 버튼 클릭 등)를 감지하면, 루프를 종료하여 프로그램을 종료한다.
  
- **타이머를 통한 자동 종료:**  
  예제에서는 일정 시간(예: 3초)이 경과하면 자동으로 이벤트 루프를 종료하여, 창이 일정 시간 동안 표시되도록 한다.

---

#### 3.4 실습 예제 코드

아래는 위의 내용을 모두 반영한 SDL 기반의 간단한 그래픽 애플리케이션 예제 코드이다:

```c
#include <SDL.h>
#include <stdio.h>

int main(int argc, char* argv[]) {
    // 1. SDL 초기화
    if (SDL_Init(SDL_INIT_VIDEO) != 0) {
        printf("SDL 초기화 실패: %s\n", SDL_GetError());
        return 1;
    }

    // 2. 창 생성 (800x600 크기의 창, 중앙 배치)
    SDL_Window* window = SDL_CreateWindow("SDL 창 생성 및 그리기 예제",
                                          SDL_WINDOWPOS_CENTERED,
                                          SDL_WINDOWPOS_CENTERED,
                                          800, 600,
                                          SDL_WINDOW_SHOWN);
    if (window == NULL) {
        printf("창 생성 실패: %s\n", SDL_GetError());
        SDL_Quit();
        return 1;
    }

    // 3. 렌더러 생성
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (renderer == NULL) {
        printf("렌더러 생성 실패: %s\n", SDL_GetError());
        SDL_DestroyWindow(window);
        SDL_Quit();
        return 1;
    }

    // 4. 배경 그리기: 검정색으로 채우기
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderClear(renderer);

    // 5. 기본 도형 그리기: 흰색 사각형
    SDL_Rect rect = {200, 150, 400, 300};  // 사각형의 위치와 크기 지정
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);  // 흰색 설정
    SDL_RenderFillRect(renderer, &rect);

    // 6. 렌더링 결과 출력
    SDL_RenderPresent(renderer);

    // 7. 이벤트 처리: 3초 동안 대기하거나 창 닫기 이벤트 발생 시 종료
    SDL_Event e;
    int running = 1;
    Uint32 start_time = SDL_GetTicks();
    while (running) {
        while (SDL_PollEvent(&e)) {
            if (e.type == SDL_QUIT) {
                running = 0;
            }
        }
        // 3초가 경과하면 루프 종료
        if (SDL_GetTicks() - start_time > 3000) {
            running = 0;
        }
    }

    // 8. 자원 해제 및 종료
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();
    return 0;
}
```

---

#### 3.5 요약

- **창 생성:** SDL을 초기화하고, `SDL_CreateWindow` 및 `SDL_CreateRenderer`를 사용해 창과 렌더러를 생성한다.
- **기본 그리기:** 렌더러의 배경을 특정 색으로 채우고, `SDL_RenderFillRect` 등의 함수를 통해 기본 도형을 그린 후, `SDL_RenderPresent`로 결과를 출력한다.
- **이벤트 처리:** 이벤트 루프를 구성하여 사용자의 입력(창 닫기 등)을 감지하고, 일정 시간 후 자동 종료되는 기능을 구현한다.

이 실습을 통해 학생들은 SDL을 사용한 기본 창 생성, 그리기 및 이벤트 처리 기법을 체험하며, 그래픽스 프로그래밍의 기초를 직접 구현해 볼 수 있다.

### 4. 간단한 그래픽 애플리케이션 구현

이 항목에서는 앞서 배운 창 생성, 기본 그리기, 이벤트 처리 기능을 하나로 통합하여, 실시간 애니메이션이 포함된 간단한 그래픽 애플리케이션을 구현하는 방법을 다룬다.

---

#### 4.1 목표 및 설계 개요

- **목표:**  
  창을 생성하고, 화면에 도형을 그리며, 사용자의 입력 및 창의 경계와의 충돌에 따라 도형의 위치를 업데이트하는 애니메이션 애플리케이션을 구현한다.

- **설계 개요:**  
  1. SDL 초기화 및 창과 렌더러 생성  
  2. 기본 도형(사각형)을 정의하고, 초기 위치 및 이동 속도를 설정  
  3. 메인 루프에서 이벤트 처리 및 애니메이션 업데이트 수행  
  4. 매 프레임마다 화면을 새로 그려 도형의 현재 위치를 출력  
  5. 프로그램 종료 시, 할당된 리소스를 적절히 해제

---

#### 4.2 예제 코드

```c
#include <SDL.h>
#include <stdio.h>

int main(int argc, char* argv[]) {
    // 1. SDL 초기화
    if (SDL_Init(SDL_INIT_VIDEO) != 0) {
        printf("SDL 초기화 실패: %s\n", SDL_GetError());
        return 1;
    }

    // 2. 창 생성 (800x600 크기의 창, 중앙 배치)
    SDL_Window* window = SDL_CreateWindow("간단한 그래픽 애플리케이션",
                                          SDL_WINDOWPOS_CENTERED,
                                          SDL_WINDOWPOS_CENTERED,
                                          800, 600,
                                          SDL_WINDOW_SHOWN);
    if (window == NULL) {
        printf("창 생성 실패: %s\n", SDL_GetError());
        SDL_Quit();
        return 1;
    }

    // 3. 렌더러 생성
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (renderer == NULL) {
        printf("렌더러 생성 실패: %s\n", SDL_GetError());
        SDL_DestroyWindow(window);
        SDL_Quit();
        return 1;
    }

    // 4. 애니메이션에 필요한 변수 초기화
    SDL_Rect rect = {100, 100, 50, 50}; // 사각형의 초기 위치와 크기
    int velX = 5;  // x축 이동 속도
    int velY = 3;  // y축 이동 속도

    int running = 1;
    SDL_Event e;

    // 5. 메인 이벤트 및 렌더링 루프
    while (running) {
        // 이벤트 처리: 창 닫기 이벤트 확인
        while (SDL_PollEvent(&e)) {
            if (e.type == SDL_QUIT) {
                running = 0;
            }
        }

        // 사각형 위치 업데이트
        rect.x += velX;
        rect.y += velY;

        // 창 경계와 충돌 시 이동 방향 반전
        if (rect.x <= 0 || rect.x + rect.w >= 800) {
            velX = -velX;
        }
        if (rect.y <= 0 || rect.y + rect.h >= 600) {
            velY = -velY;
        }

        // 화면 클리어 및 배경 채우기 (검정색)
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderClear(renderer);

        // 사각형 그리기 (하얀색)
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        SDL_RenderFillRect(renderer, &rect);

        // 렌더링 업데이트: 그리기 결과를 화면에 출력
        SDL_RenderPresent(renderer);

        // 프레임 딜레이 (약 60fps 유지)
        SDL_Delay(16);
    }

    // 6. 자원 해제 및 종료
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();
    return 0;
}
```

---

#### 4.3 코드 설명

- **초기화 및 창/렌더러 생성:**  
  - `SDL_Init` 함수로 SDL 비디오 시스템을 초기화하고, `SDL_CreateWindow`로 800x600 크기의 창을 중앙에 생성한다.  
  - `SDL_CreateRenderer`를 호출하여, 창에 연결된 렌더러를 생성한다.

- **애니메이션 변수 설정:**  
  - `SDL_Rect rect`를 이용해 화면에 그릴 사각형의 위치와 크기를 정의한다.  
  - `velX`와 `velY`는 사각형이 x축과 y축으로 이동할 속도를 나타내며, 이를 통해 사각형이 창 내에서 움직이도록 한다.

- **메인 루프와 이벤트 처리:**  
  - `SDL_PollEvent`를 사용하여 창 닫기 등의 이벤트를 처리하고, 사용자 입력에 따라 프로그램을 종료할 수 있도록 한다.
  - 매 루프마다 사각형의 위치를 업데이트하고, 창의 경계에 도달하면 이동 방향을 반전시켜 도형이 화면 내에서 튕기듯 움직이도록 한다.

- **렌더링:**  
  - `SDL_SetRenderDrawColor`와 `SDL_RenderClear`를 통해 렌더러의 배경을 검정색으로 채우고,  
  - 흰색으로 사각형을 그린 후 `SDL_RenderPresent`로 그리기 결과를 창에 출력한다.

- **프레임 제어:**  
  - `SDL_Delay(16)`로 약 16밀리초씩 대기하여, 약 60fps의 애니메이션 효과를 구현한다.

- **자원 해제:**  
  - 프로그램 종료 전에 생성된 렌더러와 창을 적절하게 파괴하고, `SDL_Quit`을 호출하여 SDL을 종료한다.

---

#### 4.4 요약

이 예제는 SDL을 이용해 간단한 그래픽 애플리케이션을 구현하는 전체 과정을 보여준다.  
- **창 생성 및 렌더러 초기화**로 시작하여,  
- **기본 도형(사각형) 그리기** 및 **애니메이션**을 위한 사각형의 위치 업데이트,  
- **이벤트 처리**를 통해 창 닫기 등의 사용자 입력을 반영하며,  
- **렌더링**을 통해 매 프레임 업데이트된 결과를 화면에 출력한다.

이 과정을 통해 학생들은 SDL을 활용한 그래픽 애플리케이션 개발의 기초를 실제로 체험하고, 다양한 기능들을 통합하여 응용 프로그램을 만드는 방법을 배울 수 있다.
